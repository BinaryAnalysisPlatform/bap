open Core_kernel
open Bap_core_theory
open Bap.Std

module Name = struct
  type t = Xmlm.name
  let matches ?(ns="") what (uri,name) =
    [%equal : (string * string)] (ns,what) (uri,name)
end

module Attributes = struct
  type t = Xmlm.attribute list

  let lookup attrs attr = List.find_map attrs ~f:(fun (k,v) ->
      Option.some_if (Name.matches attr k) v)

  type 'a arg = t -> 'a option
  let str name : string arg = fun attrs -> lookup attrs name
  let int name : int arg = fun attrs ->
    match lookup attrs name with
    | None -> None
    | Some x -> try Some (int_of_string x) with _ -> None

  let ($) : ('a -> 'b) arg -> 'a arg -> 'b arg =
    fun argf arg attrs ->
    match argf attrs, arg attrs with
    | Some f, Some x -> Some (f x)
    | _,_ -> None

  let const : 'a -> 'a arg =
    fun x _ -> Some x
end

type name = Name.t
type attributes = Attributes.t



(** The parser combinator library for XML streams.

    A parser is stateful machine that recognizes a sequence of XML
    tokens (signals). A parser combinator is a function that takes
    several parsers and produces another parser. When a parser
    recognizes a sequence of tokens it generates a value, which
    witnesses that the parser was used in the derivation. A parser may
    recognize an empty sequence of tokens, i.e., it doesn't consume
    any input, e.g., [return ()] produces [()] without consuming any
    tokens. Values generated by parsers could be a parsers
    themselves, therefore the generated grammar is value-dependent and
    can recongize language that are describe with context-sensitive
    grammars.

    The XMLM source is destructive so we keep an extra state to keep
    track of the consumed tokens and to enable better error
    messages. Whether a parser is consuming a token or not is stored
    in its state. It is a dynamic property, since a parser could be
    combined from parsers that either consume or not. For example,

    {[
      let foo = element "foo" >>$ `foo
      let bar = return `bar
      let exp = foo <|> bar
    ]}

    when [exp] matches a sequence of tokens it could either use the
    [foo] or [bar] deriviation and either consume ([foo]) or not
    ([bar]) tokens. In the following example,

    {[
      let start = exp >>= function
        | `bar -> return 1
        | `foo -> return 2
    ]}

    the produced parser [start] will consume tokens if [foo] is
    in the derivation, despite that the parser was created with
    [return 2].

    The parser may fail because it doesn't recognize the sequence of
    tokens, the soft failure, or because a runtime error happened, the
    hard error. A soft error is normal during parsing and could be
    backtracked with [<|>] and other operators. The hard error can
    never be backtracked and immediately halts parsing.
    The runtime error can be generated with [error msg] or result from
    an error in the underlying source.
*)
module Parser : sig

  (** ['a t] is the parser that generates a value of type ['a].*)
  type 'a t

  (** the representation of the parsing error.  *)
  type error


  (** [p >>= f] creates context-dependent parser.

      If [p] succeeds with [x] then uses [f x] to create a new parser
      that depends on [x]. If it fails, then [f] is not called.

      The resulting grammar is [R ::= pq], where [q] is [f x].
  *)
  val ( >>= ) : 'a t -> ('a -> 'b t) -> 'b t

  (** [return x] always succeeds and generates [x].

      The parser doesn't affect the state.
  *)
  val return : 'a -> 'a t

  (** [p >>| f] maps with [f] the result of [p].

      Creates a parser that returns [f x] if [p] succeeds with [x].

      The resulting grammar is [R := pq], where [q] is
      [return (f x)]. The [q] parser grammar is [É›], i.e., it matches
      with an empty string. *)
  val ( >>| ) : 'a t -> ('a -> 'b) -> 'b t

  (** [p >> q] composes [p] and [q].

      the generated grammar is [pq] and the result of [p >> q] is the
      result of [q] (the result of [p] is ignored).
  *)
  val ( >> ) : 'a t -> 'b t -> 'b t

  (** [p << q] if [p] followed [q] succeeds, returns the result of [p] *)
  val ( << ) : 'a t -> 'b t -> 'a t

  (** [p >>$ x] if [p] succeeds returns [x]. *)
  val ( >>$ ) : 'a t -> 'b -> 'b t

  (** [p <|> q] if [p]   *)
  val ( <|> ) : 'a t -> 'a t -> 'a t

  (** [!*p] reconizes zero or more [p],

      see {!fold} for more details.*)
  val (!*) : 'a t -> 'a list t

  (** [!+p] recognizes one or more [p] *)
  val (!+) : 'a t -> 'a list t

  (** [star p = !*p]  *)
  val star : 'a t -> 'a list t

  (** [plus p = !+p]  *)
  val plus : 'a t -> 'a list t

  (** [many p = star p = !*p]  *)
  val many : 'a t -> 'a list t

  (** [ignore p = p >>$ ()] *)
  val ignore : 'a t -> unit t


  (** [choice [p; q; ...; z] is [p <|> q <|> ... z].  *)
  val choice : 'a t list -> 'a t

  (** [required p] rejects [p] if it's value is [None] *)
  val required : 'a option t -> 'a t

  (** [fold p f x] folds over the successive derivation of [p].

      Generates the longest possible derivation of [p] by trying it
      as long as it consumes input _and_ generates values.

      The resulting parser will consume input if at least one of the
      derivations of [p] was consuming. If [plus] is true and [p]
      didn't consume input (i.e., [f] was never called) then the
      derivation is rejected and [fold ~plus p f x] doesn't generate
      any value.

      The [fold] function is a generic function that is used to
      implement [star], [many], and [plus].
  *)
  val fold : ?plus:bool -> 'a t -> ('b -> 'a -> 'b) -> 'b -> 'b t

  (** XML-specific grammar elements  *)

  (** [dtd] recognizes DTD or its absence.

      Matches with the [`Dtd] signal or with an empty sequence.
      This parser never rejects any input.
  *)
  val dtd : Xmlm.dtd t

  (** [eoi] matches with the end of input.  *)
  val eoi : bool t

  (** [any] recognizes any XML tree.

      The recognized subtree is read (including all chidlren) and
      discarded.
  *)
  val any : unit t

  (** [tag name] recognizes tag with the given name.

      Recognizes the start-tag of an element with the given [name].
      Note, the empty-element tag is represented with two XML tokens
      (signals), the start-tag and the end-tag.

      Note, each start-tag should be accompanied with a corresponding
      end-tag, see {!close}. This parser only matches the start-tag.
  *)
  val tag : string -> attributes t



  (** [start] recognizes a start tag with any name.

      Produces the name of the recognized tag together with the
      attributes.
  *)
  val start : Xmlm.tag t


  (** [close] recognizes any end-tag. *)
  val close : unit t

  (** [tree name children] recognizes an element with [children].

      Recognizes an element with the given [name] that has contents
      that is recognized by [children]. Returns a pair composed of
      the attributes of the matched element and the result of the
      [children] parser.
  *)
  val tree : string -> 'a t -> (attributes * 'a) t

  (** [attr tag attr] recognizes an element with attribute.

      Recognizes and element with the given name that has an attribute
      named [attr], returns the value of that attribute.
  *)
  val attr : string -> string -> string t

  (** [data] recongizes the non-markup contents of an element. *)
  val data : string t

  (** [error msg] is a parser that stops parsing with the error [msg].  *)
  val error : string -> 'a t

  (** [run parser input] runs the [parser] on the specified [input]. *)
  val run : 'a t -> Xmlm.input -> ('a,error) result

  (** [pp_error ppf err] prints the parsing error.  *)
  val pp_error : Format.formatter -> error -> unit
end = struct
  type reject =
    | No_input
    | Unexpected of Xmlm.signal
    | User_error of string
    | Missing_attribute of {tag: string; attr : string}
    | Is_required

  type state = {
    input : Xmlm.input;
    empty : bool;
  }

  type 'a parser = state -> state * ('a,reject) result
  type 'a t = 'a parser

  type error = Xmlm.pos * reject

  let empty v s = {s with empty=true},v
  let unexpected signal = empty@@Error (Unexpected signal)
  let return x s = s,Ok x
  let const x s = {s with empty=true}, Ok x
  let fail err s = s,Error err
  let reject signal s = unexpected signal s

  let eof s = {s with empty=true},Error No_input

  let read : _ parser = fun s ->
    if Xmlm.eoi s.input then eof s
    else {s with empty=false},Ok (Xmlm.input s.input)

  let peek s =
    if Xmlm.eoi s.input then eof s
    else s,Ok (Xmlm.peek s.input)

  let (>>=) : 'a parser -> ('a -> 'b parser) -> 'b parser =
    fun p f s ->
    match p s with
    | _,Error _ as err -> err
    | s,Ok r -> f r s

  let (>>|) p f = p >>= fun x -> return (f x)

  let (>>) p q = p >>= fun _ -> q

  let ignore p = p >>| ignore

  let drop = ignore read
  let consumed r =
    drop >>= fun () -> return r

  let dtd = peek >>= function
    | `Dtd x -> consumed x
    | _ -> return None

  let start =
    peek >>= function
    | `El_start (name,attrs) ->
      consumed (name,attrs)
    | s -> reject s

  let close =
    peek >>= function
    | `El_end -> consumed ()
    | s -> reject s


  let tag name = peek >>= function
    | `El_start (tag,attrs) when Name.matches name tag ->
      consumed attrs
    | s -> reject s

  let eoi s = s, Ok (Xmlm.eoi s.input)

  let any s =
    let rec loop level s =
      if Xmlm.eoi s.input then s,Error No_input
      else match Xmlm.input s.input with
        | `Dtd _ | `Data _ -> loop level s
        | `El_end when level = 0 -> s, Ok ()
        | `El_end -> loop (level-1) s
        | `El_start _ -> loop (level+1) s in
    if Xmlm.eoi s.input then {s with empty=true}, Ok ()
    else match Xmlm.peek s.input with
      | `El_start _ ->
        let _ : Xmlm.signal = Xmlm.input s.input in
        loop 0 {s with empty=false}
      | other -> {s with empty=true}, Error (Unexpected other)


  let (>>$) p x = p >> return x
  let (<<) p q = p >>= fun x -> q >> return x


  let matches_attr name ((_,id),_) = String.equal name id

  let attr tname aname =
    tag tname >>= fun attrs ->
    match List.find attrs ~f:(matches_attr aname) with
    | None -> fail (Missing_attribute {tag=tname; attr=aname})
    | Some (_,v) -> return v

  let element name =
    tag name >>= fun attrs ->
    peek >>= function
    | `Data payload -> consumed (attrs,payload) << close
    | signal -> reject signal

  let data =
    peek >>= function
    | `Data payload -> consumed payload
    | signal -> reject signal

  let tree name children =
    tag name >>= fun attrs ->
    children >>= fun child ->
    return (attrs,child)
    << close


  let (<|>) : 'a parser -> 'a parser -> 'a parser = fun p q s ->
    match p {s with empty=true} with
    | _,Ok _ as ok -> ok
    | {empty=true},Error (Unexpected _|Is_required) -> q s
    | _,Error _ as err -> err


  let choice parsers =
    List.reduce_exn parsers ~f:(<|>)

  let fold ?(plus=false) : 'a parser -> ('b -> 'a -> 'b) -> 'b -> 'b parser =
    fun p f xs s ->
    let finish xs empty s =
      {s with empty},
      if empty && plus then Error Is_required else Ok xs in
    let rec loop xs empty s = match p s with
      | {empty=false} as s,Ok x ->
        loop (f xs x) false s
      | {empty=true} as s,Ok x -> finish (f xs x) empty s
      | {empty=true},Error (Unexpected _| Is_required|No_input) ->
        finish xs empty s
      | _,Error _ as err -> err in
    loop xs true {s with empty=true}

  let list_rev ?plus : 'a parser -> 'a list parser = fun p ->
    fold p ?plus (fun xs x -> x::xs) []

  let list ?plus p = list_rev ?plus p >>| List.rev

  let star s = list ~plus:false s
  let many s = star s
  let plus s = list ~plus:true s

  let (!*) = star
  let (!+) = plus

  let required p =
    p >>= function
    | None -> fail Is_required
    | Some x -> return x

  let error msg : 'a parser = fun s -> s,(Error (User_error msg))

  let run : 'a parser -> Xmlm.input -> _ =
    fun p s -> match p {input=s; empty=true} with
      | s,Error rej -> Error (Xmlm.pos s.input,rej)
      | _,(Ok _ as ok) -> ok

  let pp_error ppf ((lin,col),reject) =
    Format.fprintf ppf "Parser failed at line %d, column %d.@\n" lin col;
    match reject with
    | No_input -> Format.fprintf ppf "Unexpected end of input"
    | Unexpected (`El_start (name,_)) ->
      Format.fprintf ppf "An unexpected tag %a" Xmlm.pp_name name
    | Unexpected `El_end ->
      Format.fprintf ppf "An unexpected end-tag"
    | Unexpected `Dtd _ ->
      Format.fprintf ppf "An unexpected start of the document (DTD)"
    | Unexpected `Data data ->
      Format.fprintf ppf "An unexpected element content: %S" data
    | User_error msg ->
      Format.fprintf ppf "%s" msg
    | Missing_attribute {tag: string; attr : string} ->
      Format.fprintf ppf "The attribute %S of the tag '%s' is required"
        attr tag
    | Is_required ->
      Format.fprintf ppf "The element is required"

end

module Action : sig
  type t
  val of_tag : Xmlm.tag -> t
  val pp : Format.formatter -> t -> unit
  include Base.Comparable.S with type t := t
end = struct
  type action = {
    name : KB.Name.t;
    args : string Map.M(KB.Name).t;
  }
  [@@deriving compare, equal, sexp]

  let xml_name ~default (pkg,name) = match pkg with
    | "" -> KB.Name.create ~package:default name
    | _ -> match Uri.(host@@of_string pkg) with
      | None | Some "" -> KB.Name.create ~package:pkg name
      | Some package -> KB.Name.create ~package name

  let of_tag (name,args) = {
    name = xml_name ~default:"bap" name;
    args = List.map args ~f:(fun (k,v) ->
        xml_name ~default:KB.Symbol.keyword k,v) |>
           Map.of_alist_exn (module KB.Name)
  }

  let pp_arg ppf (name,value) =
    Format.fprintf ppf "%a %S"
      KB.Name.pp name value

  let pp_args ppf args =
    Format.pp_print_list ~pp_sep:Format.pp_print_space
      pp_arg ppf (Map.to_alist args)

  let pp ppf {name; args} =
    if Map.is_empty args
    then Format.fprintf ppf "(%a)" KB.Name.pp name
    else Format.fprintf ppf "@[<hv2>(%a@ %a)@]"
        KB.Name.pp name pp_args args

  type t = action
  include Base.Comparable.Make(struct
      type nonrec t = action [@@deriving compare, sexp]
    end)
end

module Pattern : sig
  type t
  type field

  val create : string -> t
  val concat : t -> t -> t
  val length : t -> int
  val size : t -> int
  val nth : field -> t -> int -> int
  val bits : field
  val mask : field
  val matches : t -> pos:int -> int -> bool
  val pp : Format.formatter -> t -> unit
end = struct
  module Parser = struct
    type mode = Start | Wait | Bin | Hex

    type state = {
      bits : Z.t;
      mask : Z.t;
      size : int;
      mode : mode;
    }

    let init = {
      bits = Z.zero;
      mask = Z.zero;
      size = 0;
      mode = Start
    }

    let switch mode s = {s with mode}

    let bit bit s = {
      mode = Bin;
      size = s.size + 1;
      bits = Z.(s.bits lsl 1 lor of_int bit);
      mask = Z.(s.mask lsl 1 lor one);
    }

    let mask_bit s = {
      mode = Bin;
      size = s.size + 1;
      bits = Z.(s.bits lsl 1);
      mask = Z.(s.mask lsl 1)
    }

    let nib x s = {
      mode = Hex;
      size = s.size + 4;
      bits = Z.(s.bits lsl 4 lor of_string_base 16 (String.of_char x));
      mask = Z.(s.mask lsl 4 lor of_int 0xf)
    }

    let mask_nib s = {
      mode = Hex;
      size = s.size + 4;
      bits = Z.(s.bits lsl 4);
      mask = Z.(s.mask lsl 4)
    }

    let seq s f =
      List.fold f ~init:s ~f:(fun s push -> push s)

    let run = String.fold ~init ~f:(fun s c -> match s.mode,c with
        | Start, '1' -> bit 1 s
        | Start, '0' -> switch Wait s
        | Start, '.' -> mask_bit s
        | Start, _ -> s
        | Wait, '0' -> seq s [bit 0; bit 0]
        | Wait, '1' -> seq s [bit 0; bit 1]
        | Wait, 'x' -> switch Hex s
        | Wait, _ -> switch Start s
        | Bin, '0' -> bit 0 s
        | Bin, '1' -> bit 1 s
        | Bin, '.' -> mask_bit s
        | Bin, _ -> switch Start s
        | Hex, ' ' -> switch Start s
        | Hex, '.' -> mask_nib s
        | Hex, '_' -> s
        | Hex, x -> nib x s)
  end


  type t = {
    repr : string;
    bits : Z.t;
    mask : Z.t;
    pops : int;
    size : int;
  }

  type field = t -> Z.t

  let create repr =
    let {Parser.size; bits; mask} = Parser.run repr in
    {bits; mask; size; pops = Z.popcount mask; repr}

  let bits x = x.bits
  let mask x = x.mask
  let size x = x.size
  let length x = x.size / 8


  let concat x y = {
    repr = x.repr ^ y.repr;
    bits = Z.(x.bits lsl y.size lor y.bits);
    mask = Z.(x.mask lsl y.size lor y.mask);
    pops = x.pops + y.pops;
    size = x.size + y.size;
  }

  let nth what x n =
    let off = (x.size / 8 - n - 1) * 8 in
    Z.to_int @@
    Z.(what x asr off land of_int 0xff)

  let matches x ~pos:n data =
    let mask = nth mask x n
    and bits = nth bits x n in
    data land mask = bits

  let pp ppf {repr} =
    Format.fprintf ppf "%s" repr
end

module Target = struct

  (* None denotes any *)
  type spec = {
    arch : string;
    order : Theory.endianness option;
    bits : int option;
    variant : string option;
    compiler : string option;
  } [@@deriving fields]

  type t =
    | Name of Theory.Target.t
    | Spec of spec

  type problem =
    | Wrong_endianness
    | Unrecognized_target

  type match_kind = Generic | Specific

  exception Wrong_arch_spec of problem

  let fail problem = raise (Wrong_arch_spec problem)

  let with_default field k =
    match field with
    | "default"|"*" -> None
    | other -> Some (k other)

  let of_parts arch order bits rest =
    let arch = String.lowercase arch in
    let bits = with_default bits Int.of_string in
    let order = with_default order @@ function
      | "LE" -> Theory.Endianness.le
      | "BE" -> Theory.Endianness.eb
      | "LEBE" ->  Theory.Endianness.bi
      | _ -> fail Wrong_endianness in
    let variant = match List.hd rest with
      | None -> None
      | Some var -> with_default var ident in
    let compiler = match rest with
      | [_;comp] -> with_default comp ident
      | _ -> None in
    Spec {arch; bits; order; variant; compiler}

  let parse str = match String.split str ~on:':' with
    | arch::order::bits::rest -> of_parts arch order bits rest
    | _ -> match Theory.Target.lookup ~package:"bap" str with
      | None -> fail Unrecognized_target
      | Some t -> Name t

  let field_matches equal value field = match field with
    | None -> true
    | Some field -> equal value field

  let matches target = function
    | Name t -> Theory.Target.belongs t target
    | Spec s ->
      let bits = Theory.Target.bits target in
      let order = Theory.Target.endianness target in
      field_matches equal bits s.bits &&
      field_matches Theory.Endianness.equal order s.order &&
      Theory.Target.matches target s.arch
end

module Rule = struct

  type sizes = {
    total : int;
    post : int;
  }

  type t = {
    sizes : sizes option;
    prepatterns : Pattern.t list;
    postpatterns  : Pattern.t list;
    actions : Action.t list
  }

  let empty = {
    sizes = None;
    prepatterns = [];
    postpatterns = [];
    actions = []
  }

  let sizes total post = {total; post}

  let collapse matches = {
    sizes = List.find_map matches ~f:(fun {sizes} -> sizes);
    prepatterns = List.(matches >>= fun {prepatterns=xs} -> xs);
    postpatterns = List.(matches >>= fun {postpatterns=xs} -> xs);
    actions= List.(matches >>= fun {actions=xs} -> xs);
  }

  let pp_patterns = Format.pp_print_list Pattern.pp
  let pp_actions = Format.pp_print_list Action.pp

  let pp ppf {prepatterns; postpatterns; actions} =
    Format.fprintf ppf "@[<v>\
                        @[<v2>preps {@;%a@]@;}@;\
                        @[<v2>posts {@;%a@]@;}@;\
                        @[<v2>actions {@;%a@]@;}@;\
                        @]"
      pp_patterns prepatterns
      pp_patterns postpatterns
      pp_actions actions
end

module Grammar = struct
  open Parser

  let file = tree "patternfile" data >>| snd

  let file_with_compiler =
    attr "compiler" "id" >>= fun compiler ->
    file >>= fun file ->
    return (compiler,file)
    << close

  let with_compilers id =
    plus file_with_compiler >>| List.map ~f:(fun (comp,file) ->
        sprintf "%s:%s" id comp, file)

  let without_compilers id =
    file >>= fun file ->
    return [id,file]

  let language =
    attr "language" "id" >>= fun id ->
    (with_compilers id <|> without_compilers id) <<
    close

  let files =
    dtd >>
    tag "patternconstraints" >>
    plus language <<
    close

  let data = tree "data" data >>| snd

  let prepatterns =
    tree "prepatterns" (plus data) >>| snd >>| List.map ~f:Pattern.create


  let patternpairs_open_tag =
    tag "patternpairs" >>|
    Attributes.(const (fun x y -> Rule.sizes x y)
                $ int "totalbits" $ int "postbits")

  let action = start << close >>| fun a -> {
      Rule.empty with actions = [Action.of_tag a]
    }

  let data_elt =
    data >>| fun p -> {
      Rule.empty with postpatterns = [Pattern.create p]
    }

  let patterns_with_actions name =
    tag name >>
    !*(data_elt <|> action) >>= fun matches ->
    return (Rule.collapse matches) <<
    close

  let postpatterns =
    patterns_with_actions "postpatterns"

  let patternpair =
    required patternpairs_open_tag >>= fun sizes ->
    prepatterns >>= fun prepatterns ->
    postpatterns >>= fun matcher -> return {
      matcher with prepatterns;
                   sizes = Some sizes;
    } << close

  let singlepattern = patterns_with_actions "pattern"

  let entries =
    star (patternpair <|> singlepattern)

  let patterns =
    dtd >>
    tag "patternlist" >>
    entries <<
    close
end

module Rules = struct
  type case = {
    pattern : Pattern.t;        (* the pattern to match *)
    actions : Set.M(Action).t;  (* the actions to take *)
    shifted : int;              (* the size of the prepattern *)
  }

  type t = {
    cases : case list;          (* all possible cases *)
    known : Set.M(Action).t;    (* all possible actions from all cases *)
  }

  let pp_actions ppf actions =
    Format.pp_print_list ~pp_sep:Format.pp_print_space
      Action.pp ppf (Set.to_list actions)

  let pp_case ppf {pattern; actions} =
    Format.fprintf ppf "@[<hv2>%a ->@ %a@]"
      Pattern.pp pattern
      pp_actions actions

  let pp ppf {cases} =
    Format.fprintf ppf "@[<v>%a@]"
      (Format.pp_print_list pp_case) cases


  let is_large_enough sizes prep postp =
    match sizes with
    | None -> true
    | Some {Rule.total; post} ->
      Pattern.size postp >= post &&
      Pattern.size postp + Pattern.size prep >= total

  let empty = {
    cases = [];
    known = Set.empty (module Action);
  }

  let create rules =
    List.fold rules ~init:empty ~f:(fun rules (r : Rule.t) ->
        let actions = Set.of_list (module Action) r.actions in
        let rules = {
          rules with known = Set.union rules.known actions
        } in
        List.cartesian_product r.prepatterns r.postpatterns |>
        List.fold ~init:rules ~f:(fun rules (pre,post) ->
            if is_large_enough r.sizes pre post then
              let p = Pattern.concat pre post in {
                rules with
                cases = {
                  actions;
                  pattern=p;
                  shifted=Pattern.length pre;
                } :: rules.cases
              } else rules))

  let apply addr case f x =
    let addr = Addr.nsucc addr case.shifted in
    Set.fold case.actions ~init:x ~f:(fun x action ->
        f addr action x)

  let remove_actions work case = {
    work with known = Set.diff work.known case.actions
  }

  let search cases mem f x =
    let rec outer addr x =
      if Word.(addr < Memory.max_addr mem)
      then inner addr 0 cases x
      else x
    and inner addr pos work x =
      if Set.is_empty work.known || List.is_empty work.cases
      then outer (Addr.succ addr) x
      else match Memory.get ~index:pos ~addr mem with
        | Error _ -> x
        | Ok byte ->
          let byte = Word.to_int_exn byte in
          let x,work =
            List.fold work.cases ~init:(x,{work with cases=[]})
              ~f:(fun (x,work) case ->
                  let hits = Pattern.matches case.pattern ~pos byte in
                  if hits && Pattern.length case.pattern = pos + 1
                  then apply addr case f x, remove_actions work case
                  else x, if hits then {
                      work with cases = case :: work.cases
                    } else work) in
          inner addr (pos+1) work x in
    outer (Memory.min_addr mem) x
end

module Repository = struct
  let patternconstraints =
    FileUtil.(And (Is_file, Basename_is "patternconstraints.xml"))

  let collect_patternconstraints root =
    FileUtil.find patternconstraints root (fun xs x -> x::xs) []

  let build roots =
    List.concat_map roots ~f:collect_patternconstraints |>
    List.concat_map ~f:(fun toc ->
        let folder = FilePath.dirname toc in
        In_channel.with_file toc ~f:(fun ch ->
            let src = Xmlm.make_input ~strip:true (`Channel ch) in
            match Parser.run Grammar.files src with
            | Ok files ->
              List.concat files |>
              List.Assoc.map ~f:(fun file ->
                  Filename.concat folder file)
            | Error err ->
              Format.eprintf "illformed file %s, %a" toc Parser.pp_error err;
              []))
end

let parse_rule rule file =
  In_channel.with_file file ~f:(fun ch ->
      let src = Xmlm.make_input ~strip:true (`Channel ch) in
      Parser.(run (dtd >> rule)) src)

let parse_patterns = parse_rule Grammar.patterns

let dump_signals file =
  In_channel.with_file file ~f:(fun ch ->
      let src = Xmlm.make_input ~strip:true (`Channel ch) in
      while not (Xmlm.eoi src) do
        Format.printf "%a@\n%!" Xmlm.pp_signal (Xmlm.input src);
      done)

let pp_rules = Format.pp_print_list Rule.pp

let with_rules spec k =
  match parse_patterns spec with
  | Error err ->
    Format.eprintf "Failed to parse the spec: %a@." Parser.pp_error err
  | Ok rules ->
    let rules = Rules.create rules in
    Format.eprintf "Applying rules@\n%a@." Rules.pp rules;
    k rules

let print_matches rules mem =
  Rules.search rules mem (fun addr action () ->
      Format.printf "@[<v2>matching %a -> %a@]@\n"
        Addr.pp addr
        Action.pp action) ()

let test_on_file ~spec ~binary=
  with_rules spec @@ fun rules ->
  match Image.create ~backend:"llvm" binary with
  | Error err ->
    Format.eprintf "Failed to open the binary: %a@." Error.pp err
  | Ok (img,_) ->
    Table.iteri (Image.segments img) ~f:(fun mem seg ->
        Format.printf "Analyzing segment %s:@.%a@."
          (Image.Segment.name seg)
          Memory.pp mem;
        print_matches rules mem)

let test_on_bytes ~spec bytes =
  with_rules spec @@ fun rules ->
  let data = Bigstring.of_string bytes in
  let addr = Word.of_int32 0l in
  match Memory.create LittleEndian addr data with
  | Error err ->
    Format.printf "Wrong memory: %a@." Error.pp err
  | Ok mem -> print_matches rules mem
